/* ============================================
   Big Picture Policies - Project Page Scripts
   Scroll-driven animation + utilities
   ============================================ */

// ============================================
// 1. Configuration & Caches
// ============================================
const KEYFRAME_TIMES = [12.9, 22.6];
const NAIVE_INTERVAL = 3;
const NAIVE_COUNT = 4;
const TOTAL_SLOTS = 5;
const DURATION = 25.0;

// Wrist frames: small, high FPS (for bottom strip)
const WRIST_INTERVAL = 0.1;  // 10 FPS
const WRIST_W = 424, WRIST_H = 240;

// Overhead frames: large, lower FPS (for main video)
const OVERHEAD_INTERVAL = 0.333;  // 3 FPS
const OVERHEAD_W = 848, OVERHEAD_H = 480;

// Background color transition colors
const BG_COLOR_LIGHT = { r: 255, g: 255, b: 255 };  // #ffffff
const BG_COLOR_DARK = { r: 58, g: 58, b: 72 };      // #3a3a48

// Text color transition colors (inverse of background)
const TEXT_COLOR_DARK = { r: 26, g: 26, b: 46 };    // #1a1a2e (dark text on light bg)
const TEXT_COLOR_LIGHT = { r: 255, g: 255, b: 255 }; // #ffffff (light text on dark bg)

const wristFrameCache = new Map();
const overheadFrameCache = new Map();

// Animation duration and speed
const ANIMATION_DURATION = 60; // Total animation duration in seconds (how long to go through all segments)

// ============================================
// 2. DOM References (populated on DOMContentLoaded)
// ============================================
let scrollSection, scrollContainer, scrollSticky;
let overheadCanvas, overheadCtx, overheadWrap;
let naiveSlots = [], bppSlots = [];
let naiveContainer, bppContainer, frameStripsWrapper;
let msg1, msg2, msg3, msg4, bppTitle;
let scrollSectionHeader;
let policyInputHighlight;
let trajectorySliderContainer, trajectorySliderProgress, trajectorySliderThumb;
let animationControls, playPauseBtn, animationSliderTrack, animationSliderProgress, animationSliderThumb;
let cacheReady = false;

// Animation state
let isPlaying = false;
let animationProgress = 0; // 0 to 1
let lastFrameTime = null;
let isDragging = false;

// ============================================
// 2.5. Color Interpolation Utilities
// ============================================
function interpolateColor(color1, color2, factor) {
    // Clamp factor between 0 and 1
    factor = Math.max(0, Math.min(1, factor));
    return {
        r: Math.round(color1.r + (color2.r - color1.r) * factor),
        g: Math.round(color1.g + (color2.g - color1.g) * factor),
        b: Math.round(color1.b + (color2.b - color1.b) * factor)
    };
}

function colorToHex(color) {
    const toHex = (c) => c.toString(16).padStart(2, '0');
    return `#${toHex(color.r)}${toHex(color.g)}${toHex(color.b)}`;
}

function calculateBackgroundColor(progress) {
    // Transition points:
    // 0.00 - 0.02: Light -> Dark (fast transition)
    // 0.02 - 0.60: Stay dark
    // 0.60 - 0.65: Dark -> Light
    // 0.65+: Stay light

    let color;

    if (progress < 0.02) {
        // Transition from light to dark
        const factor = progress / 0.02;
        color = interpolateColor(BG_COLOR_LIGHT, BG_COLOR_DARK, factor);
    } else if (progress < 0.60) {
        // Stay dark
        color = BG_COLOR_DARK;
    } else if (progress < 0.65) {
        // Transition from dark to light
        const factor = (progress - 0.60) / 0.05;
        color = interpolateColor(BG_COLOR_DARK, BG_COLOR_LIGHT, factor);
    } else {
        // Stay light
        color = BG_COLOR_LIGHT;
    }

    return colorToHex(color);
}

function calculateTextColor(progress) {
    // Text color is inverse of background:
    // 0.00 - 0.02: Dark -> Light (as bg goes light -> dark)
    // 0.02 - 0.60: Stay light (on dark bg)
    // 0.60 - 0.65: Light -> Dark (as bg goes dark -> light)
    // 0.65+: Stay dark (on light bg)

    let color;

    if (progress < 0.02) {
        // Transition from dark text to light text
        const factor = progress / 0.02;
        color = interpolateColor(TEXT_COLOR_DARK, TEXT_COLOR_LIGHT, factor);
    } else if (progress < 0.60) {
        // Stay light text
        color = TEXT_COLOR_LIGHT;
    } else if (progress < 0.65) {
        // Transition from light text to dark text
        const factor = (progress - 0.60) / 0.05;
        color = interpolateColor(TEXT_COLOR_LIGHT, TEXT_COLOR_DARK, factor);
    } else {
        // Stay dark text
        color = TEXT_COLOR_DARK;
    }

    return colorToHex(color);
}

// ============================================
// 3. Frame Cache Utilities
// ============================================
function roundTime(t, interval) {
    return Math.round(t / interval) * interval;
}

function getCachedFrame(cache, time, interval) {
    const key = roundTime(Math.max(0, Math.min(time, DURATION)), interval);
    return cache.get(key) || null;
}

function loadImage(src) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`Failed to load ${src}`));
        img.src = src;
    });
}

async function loadFrameImages() {
    const loadingFill = document.getElementById('scrollLoadingFill');
    const loadingText = document.getElementById('scrollLoadingText');

    const wristFrameCount = Math.ceil(DURATION / WRIST_INTERVAL) + 1;
    const overheadFrameCount = Math.ceil(DURATION / OVERHEAD_INTERVAL) + 1;
    const totalImages = wristFrameCount + overheadFrameCount;
    let loaded = 0;

    const framePromises = [];

    // Wrist frames (10 FPS, small)
    for (let i = 0; i < wristFrameCount; i++) {
        const time = roundTime(i * WRIST_INTERVAL, WRIST_INTERVAL);
        const frameIdx = String(i).padStart(4, '0');

        framePromises.push(
            loadImage(`frames/wrist_${frameIdx}.jpg`)
                .then(img => {
                    loaded++;
                    const pct = Math.round((loaded / totalImages) * 100);
                    if (loadingFill) loadingFill.style.width = pct + '%';
                    if (loadingText) loadingText.textContent = `Loading frames... ${pct}%`;
                    return { type: 'wrist', time, img, w: WRIST_W, h: WRIST_H };
                })
                .catch(() => {
                    loaded++;
                    return null;
                })
        );
    }

    // Overhead frames (3 FPS, large)
    for (let i = 0; i < overheadFrameCount; i++) {
        const time = roundTime(i * OVERHEAD_INTERVAL, OVERHEAD_INTERVAL);
        const frameIdx = String(i).padStart(4, '0');

        framePromises.push(
            loadImage(`frames/overhead_${frameIdx}.jpg`)
                .then(img => {
                    loaded++;
                    const pct = Math.round((loaded / totalImages) * 100);
                    if (loadingFill) loadingFill.style.width = pct + '%';
                    if (loadingText) loadingText.textContent = `Loading frames... ${pct}%`;
                    return { type: 'overhead', time, img, w: OVERHEAD_W, h: OVERHEAD_H };
                })
                .catch(() => {
                    loaded++;
                    return null;
                })
        );
    }

    // Load all images in parallel
    const results = await Promise.all(framePromises);

    // Store images in caches
    for (const result of results) {
        if (!result) continue;
        const { type, time, img, w, h } = result;

        // Convert image to canvas for consistent rendering
        const canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, w, h);

        if (type === 'wrist') {
            wristFrameCache.set(time, canvas);
        } else {
            overheadFrameCache.set(time, canvas);
        }
    }

    // Hide loading overlay
    const loadingOverlay = document.getElementById('scrollLoading');
    if (loadingOverlay) {
        loadingOverlay.classList.add('hidden');
        setTimeout(() => loadingOverlay.style.display = 'none', 500);
    }

    cacheReady = true;
}

// ============================================
// 4. Slot Creation & Utilities
// ============================================
function createSlots(containerId, count) {
    const container = document.getElementById(containerId);
    if (!container) return [];
    const slots = [];
    for (let i = 0; i < count; i++) {
        const div = document.createElement('div');
        div.className = 'scroll-frame-slot empty';
        if (i === count - 1) div.classList.add('current');

        const canvas = document.createElement('canvas');
        canvas.width = WRIST_W;
        canvas.height = WRIST_H;
        div.appendChild(canvas);

        // Keyframe capture overlay
        const overlay = document.createElement('div');
        overlay.className = 'keyframe-overlay';
        overlay.textContent = 'Keyframe';
        div.appendChild(overlay);

        const label = document.createElement('div');
        label.className = 'frame-label';
        div.appendChild(label);

        container.appendChild(div);
        slots.push({ div, canvas, ctx: canvas.getContext('2d'), label, overlay });
    }
    return slots;
}

function formatTime(s) {
    const m = Math.floor(s / 60);
    const sec = (s % 60).toFixed(1);
    return `${m}:${sec.padStart(4, '0')}`;
}

function updateTrajectorySlider(videoTime, isLightBg) {
    if (!trajectorySliderContainer) return;

    // Toggle light background styling
    trajectorySliderContainer.classList.toggle('light-bg', isLightBg);

    // Update progress bar and thumb position based on video time
    const percentage = (videoTime / DURATION) * 100;

    if (trajectorySliderProgress) {
        trajectorySliderProgress.style.width = percentage + '%';
    }
    if (trajectorySliderThumb) {
        trajectorySliderThumb.style.left = percentage + '%';
    }
}

function updateAnimationControls(progress, isLightBg) {
    if (!animationControls) return;

    // Toggle light background styling
    animationControls.classList.toggle('light-bg', isLightBg);

    // Update progress bar and thumb position based on animation progress
    const percentage = progress * 100;

    if (animationSliderProgress) {
        animationSliderProgress.style.width = percentage + '%';
    }
    if (animationSliderThumb) {
        animationSliderThumb.style.left = percentage + '%';
    }
}

function clearSlot(slot) {
    slot.ctx.fillStyle = '#1a1a24';
    slot.ctx.fillRect(0, 0, slot.canvas.width, slot.canvas.height);
    slot.label.textContent = '';
    slot.div.classList.add('empty');
}

function drawCachedFrame(ctx, cache, time, interval) {
    const frame = getCachedFrame(cache, time, interval);
    if (frame) {
        ctx.drawImage(frame, 0, 0, ctx.canvas.width, ctx.canvas.height);
        return true;
    }
    return false;
}

// ============================================
// 5. Rendering Functions
// ============================================
function renderNaiveFrames(currentTime, showFailureHighlight = false) {
    for (let i = NAIVE_COUNT; i >= 0; i--) {
        const slotIdx = NAIVE_COUNT - i;
        const t = currentTime - i * NAIVE_INTERVAL;
        const slot = naiveSlots[slotIdx];
        if (!slot) continue;

        if (t < 0) {
            // Hide empty slots
            slot.div.style.display = 'none';
            slot.label.textContent = '';
        } else {
            slot.div.style.display = '';
            drawCachedFrame(slot.ctx, wristFrameCache, t, WRIST_INTERVAL);
            slot.label.textContent = (i === 0) ? 'Current Obs' : formatTime(t) + 's';
            slot.div.classList.remove('empty');
        }
        slot.div.classList.toggle('current', i === 0);
        // Highlight the two rightmost past observation frames (failed grasps) when msg2 is visible
        slot.div.classList.toggle('failure-highlight', showFailureHighlight && (i === 1 || i === 2));
    }
}

function renderBppFrames(currentTime, captureProgress = 0) {
    const isCapturing = captureProgress > 0 && captureProgress < 1;

    // During animation (0 < captureProgress < 1): PRE-capture layout (exclude keyframe at currentTime)
    // Otherwise: POST-capture layout (include keyframe at or before currentTime)
    // This ensures smooth transition when animation completes
    const seenKeyframes = isCapturing
        ? KEYFRAME_TIMES.filter(t => t < currentTime)
        : KEYFRAME_TIMES.filter(t => t <= currentTime);
    const bppEntries = [...seenKeyframes, currentTime];
    const bppDisplay = bppEntries.slice(-TOTAL_SLOTS);
    const numEntries = bppDisplay.length;

    // Two-phase animation (both use PRE-capture layout):
    // Phase 1 (0-0.6): Overlay fades in, pauses, then fades out
    // Phase 2 (0.6-1.0): All frames slide LEFT
    const inPhase1 = isCapturing && captureProgress <= 0.6;
    const inPhase2 = isCapturing && captureProgress > 0.6;

    // Overlay opacity: fade in 0-0.15, pause 0.15-0.45, fade out 0.45-0.6
    let overlayOpacity = 0;
    if (inPhase1) {
        if (captureProgress < 0.15) {
            overlayOpacity = captureProgress / 0.15;  // 0->1
        } else if (captureProgress < 0.45) {
            overlayOpacity = 1;  // stay visible
        } else {
            overlayOpacity = (0.6 - captureProgress) / 0.15;  // 1->0
        }
    }

    // Slide progress: 0 to 1 during phase 2
    const slideProgress = inPhase2 ? (captureProgress - 0.6) / 0.4 : 0;

    // Calculate actual slot step in pixels
    // Use the rightmost slot (TOTAL_SLOTS-1) which is always visible
    let slotStepPx = 0;
    const visibleSlot = bppSlots[TOTAL_SLOTS - 1];
    if (visibleSlot && visibleSlot.div) {
        const slotRect = visibleSlot.div.getBoundingClientRect();
        slotStepPx = slotRect.width + 6;
    }

    for (let i = 0; i < TOTAL_SLOTS; i++) {
        const slot = bppSlots[i];
        if (!slot) continue;

        const posFromRight = TOTAL_SLOTS - 1 - i;
        const entryFromRight = numEntries - 1 - posFromRight;

        if (entryFromRight < 0) {
            slot.div.style.display = 'none';
            slot.div.style.transform = '';
            slot.label.textContent = '';
            if (slot.overlay) slot.overlay.style.opacity = '0';
        } else {
            const t = bppDisplay[entryFromRight];
            const isCurrentFrame = (entryFromRight === numEntries - 1);

            slot.div.style.display = '';
            slot.div.classList.remove('empty');
            slot.div.style.boxShadow = '';
            slot.div.style.borderColor = '';
            slot.div.style.opacity = '1';

            // Phase 1: Show overlay on current frame
            if (inPhase1 && isCurrentFrame) {
                if (slot.overlay) slot.overlay.style.opacity = overlayOpacity.toString();
            } else {
                if (slot.overlay) slot.overlay.style.opacity = '0';
            }

            // Phase 2: ALL visible frames slide LEFT
            if (inPhase2) {
                const slideOffsetPx = slideProgress * slotStepPx;
                slot.div.style.transform = `translateX(-${slideOffsetPx}px)`;
            } else {
                slot.div.style.transform = '';
            }

            drawCachedFrame(slot.ctx, wristFrameCache, t, WRIST_INTERVAL);

            slot.label.textContent = isCurrentFrame
                ? 'Current obs'
                : `KF @ ${formatTime(t)}s`;
        }
        slot.div.classList.toggle('current', i === TOTAL_SLOTS - 1);
    }
}

// ============================================
// 6. Message Helpers
// ============================================
function positionMessage(msg, segProgress) {
    // Use container height for responsive positioning
    const containerHeight = scrollSticky ? scrollSticky.offsetHeight : window.innerHeight;

    // Get message height to properly center it
    const msgHeight = msg ? msg.offsetHeight : 100;

    // Start: below center (positive Y)
    // End: centered at 35% from top to match BPP title position
    // BPP title uses top: 35% with transform: translate(-50%, -50%), centering it at 35%
    // Messages use top: 50%, so to center at 35%:
    // 50% + translateY + (msgHeight/2) = 35% (for center)
    // translateY = -15% - (msgHeight/2)
    const startY = containerHeight * 0.12;
    const finalY = -containerHeight * 0.15 - msgHeight / 2;  // Centers message at 35% from top

    let y, opacity;

    if (segProgress < 0.3) {
        // Phase 1: Scroll from start to final position
        const phaseProgress = segProgress / 0.3;
        y = startY + phaseProgress * (finalY - startY);
        opacity = 1.0;
    } else if (segProgress < 0.75) {
        // Phase 2: Pause at final position for reading
        y = finalY;
        opacity = 1.0;
    } else {
        // Phase 3: Fade out in place (no movement)
        y = finalY;
        const phaseProgress = (segProgress - 0.75) / 0.25;
        opacity = 1 - phaseProgress;
    }

    msg.style.transform = `translateX(-50%) translateY(${y}px)`;
    msg.style.opacity = opacity;

    // Return current Y for row following calculation
    return y;
}

function hideMessage(msg) {
    msg.style.opacity = '0';
    msg.style.transform = 'translateX(-50%) translateY(120px)';
}

// Cache for naive row baseline position
let naiveRowBaselineTop = null;

function measureNaiveRowBaseline() {
    if (!naiveContainer || !scrollSticky) return;

    // Temporarily reset transform to measure natural position
    const currentTransform = naiveContainer.style.transform;
    naiveContainer.style.transform = '';

    const containerRect = scrollSticky.getBoundingClientRect();
    const rowRect = naiveContainer.getBoundingClientRect();
    naiveRowBaselineTop = rowRect.top - containerRect.top;

    // Restore transform
    naiveContainer.style.transform = currentTransform;
}

function positionNaiveRow(textY, follow = false) {
    if (!naiveContainer || !scrollSticky) return false;

    if (follow) {
        // Measure baseline on first call
        if (naiveRowBaselineTop === null) {
            measureNaiveRowBaseline();
        }
        if (naiveRowBaselineTop === null) return false;

        const containerHeight = scrollSticky.offsetHeight;
        const containerCenter = containerHeight / 2;

        // Get message height for calculating text bottom
        const msgHeight = msg2 ? msg2.offsetHeight : 100;
        const gap = 25;  // Gap between text bottom and row top

        // Text bottom position from container top
        // Message CSS: top: 50% positions TOP edge at containerCenter
        // Then translateY(textY) moves it, so:
        // - Message TOP = containerCenter + textY
        // - Message BOTTOM = containerCenter + textY + msgHeight
        const textBottomFromTop = containerCenter + textY + msgHeight;

        // Where should the row top be? Just below text bottom with a gap
        const targetRowTop = textBottomFromTop + gap;

        // How much to move up (only positive values - don't move down)
        const moveAmount = Math.max(0, naiveRowBaselineTop - targetRowTop);

        naiveContainer.style.transform = `translateY(-${moveAmount}px)`;

        // Return whether we're moving (for blur logic)
        return moveAmount > 0;
    } else {
        naiveContainer.style.transform = '';
        return false;
    }
}

function resetNaiveRowBaseline() {
    naiveRowBaselineTop = null;
}

// Cache for frame strips wrapper baseline position
let frameStripsBaselineTop = null;

function measureFrameStripsBaseline() {
    if (!frameStripsWrapper || !scrollSticky) return;

    // Temporarily reset transform to measure natural position
    const currentTransform = frameStripsWrapper.style.transform;
    frameStripsWrapper.style.transform = '';

    const containerRect = scrollSticky.getBoundingClientRect();
    const wrapperRect = frameStripsWrapper.getBoundingClientRect();
    frameStripsBaselineTop = wrapperRect.top - containerRect.top;

    // Restore transform
    frameStripsWrapper.style.transform = currentTransform;
}

function resetFrameStripsBaseline() {
    frameStripsBaselineTop = null;
}

// Position message for BPP phase (higher final position since two rows below)
function positionMessage4(msg, segProgress) {
    const containerHeight = scrollSticky ? scrollSticky.offsetHeight : window.innerHeight;
    const msgHeight = msg ? msg.offsetHeight : 100;

    // Start: below center (positive Y)
    // End: centered at ~20% from top (higher than msg2's 35% since we have two rows)
    const startY = containerHeight * 0.12;
    const finalY = -containerHeight * 0.30 - msgHeight / 2;  // Centers message at ~20% from top

    let y, opacity;

    if (segProgress < 0.3) {
        // Phase 1: Scroll from start to final position
        const phaseProgress = segProgress / 0.3;
        y = startY + phaseProgress * (finalY - startY);
        opacity = 1.0;
    } else if (segProgress < 0.75) {
        // Phase 2: Pause at final position for reading
        y = finalY;
        opacity = 1.0;
    } else {
        // Phase 3: Fade out in place (no movement)
        y = finalY;
        const phaseProgress = (segProgress - 0.75) / 0.25;
        opacity = 1 - phaseProgress;
    }

    msg.style.transform = `translateX(-50%) translateY(${y}px)`;
    msg.style.opacity = opacity;

    return y;
}

// Position BOTH rows (via wrapper) to follow msg4 text during BPP phase
// fadeProgress: 0 = fully following, 1 = fully returned to original position
function positionFrameStrips(textY, follow = false, fadeProgress = 0) {
    if (!frameStripsWrapper || !scrollSticky) return false;

    if (follow) {
        // Measure baseline on first call
        if (frameStripsBaselineTop === null) {
            measureFrameStripsBaseline();
        }
        if (frameStripsBaselineTop === null) return false;

        const containerHeight = scrollSticky.offsetHeight;
        const containerCenter = containerHeight / 2;

        // Get message height for calculating text bottom
        const msgHeight = msg4 ? msg4.offsetHeight : 100;
        const gap = 25;  // Gap between text bottom and wrapper top

        // Text bottom position from container top
        const textBottomFromTop = containerCenter + textY + msgHeight;

        // Only start moving when text bottom actually reaches the wrapper's position
        // This ensures rows follow AFTER text passes them, like the first phase
        if (textBottomFromTop <= frameStripsBaselineTop) {
            const targetWrapperTop = textBottomFromTop + gap;
            let moveAmount = frameStripsBaselineTop - targetWrapperTop;

            // During fade-out, smoothly return to original position
            if (fadeProgress > 0) {
                moveAmount = moveAmount * (1 - fadeProgress);
            }

            frameStripsWrapper.style.transform = `translateY(-${moveAmount}px)`;
            return moveAmount > 0;
        } else {
            // Text hasn't reached the wrapper yet, don't move
            frameStripsWrapper.style.transform = '';
            return false;
        }
    } else {
        frameStripsWrapper.style.transform = '';
        return false;
    }
}

// ============================================
// 7. Main Update Function
// ============================================
let lastProgress = -1;

function updateAnimation(progress) {
    if (!cacheReady) return;

    // Clamp progress
    progress = Math.max(0, Math.min(1, progress));

    // Skip if progress hasn't changed meaningfully
    if (Math.abs(progress - lastProgress) < 0.0001) return;
    lastProgress = progress;

    // Update background color based on progress
    if (scrollSticky) {
        const bgColor = calculateBackgroundColor(progress);
        scrollSticky.style.backgroundColor = bgColor;
    }

    // Update section header text color based on progress
    if (scrollSectionHeader) {
        const textColor = calculateTextColor(progress);
        scrollSectionHeader.style.color = textColor;
    }

    // Update policy input highlight visibility
    // Fade in: 0.21 → 0.23, stay visible: 0.23 → 0.26, fade out: 0.26 → 0.29
    if (policyInputHighlight) {
        let highlightOpacity = 0;
        if (progress >= 0.21 && progress < 0.23) {
            // Fade in
            highlightOpacity = (progress - 0.21) / 0.02;
        } else if (progress >= 0.23 && progress < 0.26) {
            // Stay visible
            highlightOpacity = 1;
        } else if (progress >= 0.26 && progress < 0.29) {
            // Fade out
            highlightOpacity = 1 - (progress - 0.26) / 0.03;
        }
        policyInputHighlight.style.opacity = highlightOpacity;
    }

    // Hide all messages by default
    hideMessage(msg1);
    hideMessage(msg2);
    hideMessage(msg3);
    hideMessage(msg4);

    // Reset BPP title (will be animated in segment H)
    bppTitle.style.opacity = '0';
    bppTitle.style.top = '100%';
    bppTitle.style.transform = 'translate(-50%, -50%) scale(1)';
    bppTitle.style.background = 'rgba(0, 0, 0, 0.5)';

    // ====== Segment logic ======
    let videoTime = 0;
    let showNaive = true;
    let showBpp = false;
    let bppCaptureProgress = 0;

    // Default: clear overhead blur and reset row positions
    // (will be overridden in segments E, F, and I4b)
    if (overheadWrap) {
        overheadWrap.classList.remove('blurred');
    }
    positionNaiveRow(0, false);
    if (frameStripsWrapper) {
        frameStripsWrapper.style.transform = '';
    }

    if (progress < 0.08) {
        // Segment A: 0→8s
        const segProgress = progress / 0.08;
        videoTime = segProgress * 8;
        showNaive = true;
        showBpp = false;

    } else if (progress < 0.14) {
        // Segment B: 8→14s, message 1 scrolls up
        const segProgress = (progress - 0.08) / 0.06;
        videoTime = 8 + segProgress * 6;
        const msgProgress = (progress - 0.08) / 0.12;
        positionMessage(msg1, msgProgress);
        showNaive = true;
        showBpp = false;

    } else if (progress < 0.20) {
        // Segment C: paused at 14s, message 1 continues
        videoTime = 14;
        const msgProgress = (progress - 0.08) / 0.12;
        positionMessage(msg1, msgProgress);
        showNaive = true;
        showBpp = false;

    } else if (progress < 0.38) {
        // Segment D: 14→22.6s (play to end, then pause)
        const segProgress = (progress - 0.20) / 0.18;
        videoTime = 14 + segProgress * 8.6;
        showNaive = true;
        showBpp = false;

    } else if (progress < 0.52) {
        // Segment E: paused at 22.6s, message 2 animates (with extended pause)
        // segProgress 0-0.3: animate up, 0.3-0.75: pause (glow here), 0.75-1: fade out
        const segProgress = (progress - 0.38) / 0.14;
        videoTime = 22.6;
        const textY = positionMessage(msg2, segProgress);
        showNaive = true;
        showBpp = false;

        // Make naive row follow the text during animate phase, blur when row is moving
        const isRowMoving = positionNaiveRow(textY, true);
        if (overheadWrap && (isRowMoving || segProgress >= 0.3)) {
            overheadWrap.classList.add('blurred');
        }

    } else if (progress < 0.59) {
        // Segment F: paused at 22.6s, message 3 scrolls up
        const segProgress = (progress - 0.52) / 0.07;
        videoTime = 22.6;
        positionMessage(msg3, segProgress);
        showNaive = true;
        showBpp = false;

        // Keep blur on overhead video
        if (overheadWrap) {
            overheadWrap.classList.add('blurred');
        }

        // Keep naive row at final position from segment E
        const containerHeight = scrollSticky ? scrollSticky.offsetHeight : window.innerHeight;
        const msgHeight = msg2 ? msg2.offsetHeight : 100;
        const finalTextY = -containerHeight * 0.15 - msgHeight / 2;  // Same as finalY in positionMessage
        positionNaiveRow(finalTextY, true);

    } else if (progress < 0.62) {
        // Segment G: rewind 22.6→0s
        const segProgress = (progress - 0.59) / 0.03;
        videoTime = 22.6 * (1 - segProgress);
        showNaive = true;
        showBpp = false;  // BPP row hidden during rewind
        if (naiveContainer) {
            naiveContainer.style.opacity = '1';
        }

    } else if (progress < 0.635) {
        // Segment H1: paused at 0s, BPP title rises from bottom to middle of video
        const segProgress = (progress - 0.62) / 0.015;
        videoTime = 0;
        showNaive = true;
        showBpp = false;  // BPP row hidden while title is showing
        if (naiveContainer) naiveContainer.style.opacity = '1';

        // Animate title from bottom (100%) to middle of video (~35%)
        const topPercent = 100 - segProgress * 65; // 100% -> 35%
        bppTitle.style.top = topPercent + '%';
        bppTitle.style.opacity = Math.min(1, segProgress * 2); // Fade in quickly
        bppTitle.style.transform = 'translate(-50%, -50%)';
        bppTitle.style.padding = '20px 40px';
        bppTitle.style.background = 'rgba(0, 0, 0, 0.5)';

    } else if (progress < 0.65) {
        // Segment H2: Pause - title stays in place
        videoTime = 0;
        showNaive = true;
        showBpp = false;  // BPP row hidden while title is showing
        if (naiveContainer) naiveContainer.style.opacity = '1';

        bppTitle.style.top = '35%';
        bppTitle.style.opacity = '1';
        bppTitle.style.transform = 'translate(-50%, -50%)';
        bppTitle.style.padding = '20px 40px';
        bppTitle.style.background = 'rgba(0, 0, 0, 0.5)';

    } else if (progress < 0.67) {
        // Segment H3: BPP title "pops" - background expands and fades out
        const segProgress = (progress - 0.65) / 0.02;
        videoTime = 0;
        showNaive = true;
        showBpp = false;  // BPP row hidden while title is fading
        if (naiveContainer) naiveContainer.style.opacity = '1';

        // Pop animation: background expands via padding, fades out
        const paddingV = 20 + segProgress * 40; // 20px -> 60px
        const paddingH = 40 + segProgress * 80; // 40px -> 120px
        const opacity = 1 - segProgress; // 1 -> 0
        const bgOpacity = 0.5 - segProgress * 0.5; // 0.5 -> 0

        bppTitle.style.top = '35%';
        bppTitle.style.opacity = opacity;
        bppTitle.style.transform = 'translate(-50%, -50%)';
        bppTitle.style.padding = `${paddingV}px ${paddingH}px`;
        bppTitle.style.background = `rgba(0, 0, 0, ${bgOpacity})`;

    } else if (progress < 0.755) {
        // Segment I1: Play 0 → 12.9s (first keyframe)
        const segProgress = (progress - 0.67) / 0.085;
        videoTime = segProgress * 12.9;
        showNaive = true;  // Keep naive visible below BPP
        showBpp = true;
        bppCaptureProgress = 0;
        if (naiveContainer) naiveContainer.style.opacity = '1';

    } else if (progress < 0.78) {
        // Segment I2: Pause at 12.9s - keyframe capture animation
        const segProgress = (progress - 0.755) / 0.025;
        videoTime = 12.9;
        showNaive = true;  // Keep naive visible below BPP
        showBpp = true;
        bppCaptureProgress = segProgress;
        if (naiveContainer) naiveContainer.style.opacity = '1';

    } else if (progress < 0.865) {
        // Segment I3: Play 12.9 → 22.6s (second keyframe)
        const segProgress = (progress - 0.78) / 0.085;
        videoTime = 12.9 + segProgress * (22.6 - 12.9);
        showNaive = true;  // Keep naive visible below BPP
        showBpp = true;
        bppCaptureProgress = 0;
        if (naiveContainer) naiveContainer.style.opacity = '1';

    } else if (progress < 0.89) {
        // Segment I4: Pause at 22.6s - keyframe capture animation
        const segProgress = (progress - 0.865) / 0.025;
        videoTime = 22.6;
        showNaive = true;  // Keep naive visible below BPP
        showBpp = true;
        bppCaptureProgress = segProgress;
        if (naiveContainer) naiveContainer.style.opacity = '1';

    } else if (progress < 0.97) {
        // Segment I4b: Pause at 22.6s - msg4 explanation text animation
        // segProgress 0-0.3: animate up, 0.3-0.75: pause, 0.75-1: fade out
        const segProgress = (progress - 0.89) / 0.08;
        videoTime = 22.6;
        const textY = positionMessage4(msg4, segProgress);
        showNaive = true;
        showBpp = true;
        bppCaptureProgress = 0;
        if (naiveContainer) naiveContainer.style.opacity = '1';

        // Calculate fade progress for smooth return (0 during follow, 0->1 during fade-out)
        const fadeProgress = segProgress >= 0.75 ? (segProgress - 0.75) / 0.25 : 0;

        // Rows follow text after it passes them, smoothly return during fade-out
        const isRowMoving = positionFrameStrips(textY, true, fadeProgress);
        if (overheadWrap && isRowMoving) {
            overheadWrap.classList.add('blurred');
        }

    } else {
        // Segment I5: Play 22.6 → 25s (end)
        const segProgress = (progress - 0.97) / 0.03;
        videoTime = 22.6 + segProgress * (DURATION - 22.6);
        showNaive = true;  // Keep naive visible below BPP
        showBpp = true;
        bppCaptureProgress = 0;
        if (naiveContainer) naiveContainer.style.opacity = '1';

        // Reset wrapper position and baseline
        positionFrameStrips(0, false);
        resetFrameStripsBaseline();
    }

    // Clamp video time
    videoTime = Math.max(0, Math.min(videoTime, DURATION));

    // Update sliders
    const isLightBg = progress >= 0.65;
    updateTrajectorySlider(videoTime, isLightBg);
    updateAnimationControls(progress, isLightBg);

    // Draw overhead
    drawCachedFrame(overheadCtx, overheadFrameCache, videoTime, OVERHEAD_INTERVAL);

    // Show/hide strips
    if (naiveContainer) {
        naiveContainer.style.display = showNaive ? '' : 'none';
        if (showNaive && progress < 0.52) {
            naiveContainer.style.opacity = '1';
        }
        // Add dark background when BPP is visible (light background mode)
        // Also use light text when background is dark (progress < 0.65)
        naiveContainer.classList.toggle('dark-bg', showBpp || progress < 0.65);
    }
    if (bppContainer) {
        // Use class toggle for smooth CSS transition instead of display
        bppContainer.classList.toggle('visible', showBpp);
    }
    if (frameStripsWrapper) {
        // Show gap between strips when BPP is visible
        frameStripsWrapper.classList.toggle('show-gap', showBpp);
    }

    // Render frames
    if (showNaive) {
        // Show failure highlight shortly after msg2 enters pause phase
        // Segment E: 0.38-0.52, pause phase starts at 0.422, delay glow slightly
        const showFailureHighlight = progress >= 0.44 && progress < 0.485;
        renderNaiveFrames(videoTime, showFailureHighlight);
    }
    if (showBpp) {
        renderBppFrames(videoTime, bppCaptureProgress);
    }
}

// ============================================
// 8. Animation Loop & Controls
// ============================================

function animationLoop(currentTime) {
    if (!isPlaying) {
        lastFrameTime = null;
        return;
    }

    if (lastFrameTime === null) {
        lastFrameTime = currentTime;
    }

    const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
    lastFrameTime = currentTime;

    // Update progress
    animationProgress += deltaTime / ANIMATION_DURATION;

    // Loop when finished
    if (animationProgress >= 1) {
        animationProgress = 0;
        // Reset baselines for smooth looping
        resetNaiveRowBaseline();
        resetFrameStripsBaseline();
    }

    updateAnimation(animationProgress);
    requestAnimationFrame(animationLoop);
}

function play() {
    if (isPlaying) return;
    isPlaying = true;
    lastFrameTime = null;
    if (playPauseBtn) playPauseBtn.classList.add('playing');
    requestAnimationFrame(animationLoop);
}

function pause() {
    isPlaying = false;
    if (playPauseBtn) playPauseBtn.classList.remove('playing');
}

function togglePlayPause() {
    if (isPlaying) {
        pause();
    } else {
        play();
    }
}

function seekToProgress(progress) {
    animationProgress = Math.max(0, Math.min(1, progress));
    // Reset baselines when seeking
    resetNaiveRowBaseline();
    resetFrameStripsBaseline();
    updateAnimation(animationProgress);
}

function handleSliderInteraction(event) {
    if (!animationSliderTrack) return;

    const rect = animationSliderTrack.getBoundingClientRect();
    const x = (event.touches ? event.touches[0].clientX : event.clientX) - rect.left;
    const progress = Math.max(0, Math.min(1, x / rect.width));

    seekToProgress(progress);
}

function startDrag(event) {
    isDragging = true;
    pause(); // Pause while dragging
    handleSliderInteraction(event);
    event.preventDefault();
}

function doDrag(event) {
    if (!isDragging) return;
    handleSliderInteraction(event);
    event.preventDefault();
}

function endDrag() {
    if (!isDragging) return;
    isDragging = false;
}

function initAnimationControls() {
    // Play/Pause button
    if (playPauseBtn) {
        playPauseBtn.addEventListener('click', togglePlayPause);
    }

    // Slider interactions
    if (animationSliderTrack) {
        // Mouse events
        animationSliderTrack.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', endDrag);

        // Touch events
        animationSliderTrack.addEventListener('touchstart', startDrag, { passive: false });
        document.addEventListener('touchmove', doDrag, { passive: false });
        document.addEventListener('touchend', endDrag);
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
        // Only respond if the animation section is visible
        if (!scrollSection) return;
        const rect = scrollSection.getBoundingClientRect();
        const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
        if (!isVisible) return;

        if (e.code === 'Space') {
            togglePlayPause();
            e.preventDefault();
        } else if (e.code === 'ArrowLeft') {
            seekToProgress(animationProgress - 0.02);
            e.preventDefault();
        } else if (e.code === 'ArrowRight') {
            seekToProgress(animationProgress + 0.02);
            e.preventDefault();
        }
    });
}

// Auto-play when section becomes visible
function initVisibilityObserver() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && entry.intersectionRatio > 0.3) {
                // Auto-play when section becomes visible
                if (cacheReady && !isPlaying) {
                    play();
                }
            } else if (!entry.isIntersecting || entry.intersectionRatio < 0.1) {
                // Pause when section leaves viewport
                pause();
            }
        });
    }, { threshold: [0.1, 0.3] });

    if (scrollSection) {
        observer.observe(scrollSection);
    }
}

// ============================================
// 9. Video Autoplay Observers
// ============================================
function initVideoAutoplay() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const video = entry.target;
            if (entry.isIntersecting) {
                video.play().catch(() => {});
            } else {
                video.pause();
            }
        });
    }, { threshold: 0.3 });

    document.querySelectorAll('.autoplay-video').forEach(video => {
        observer.observe(video);
    });
}

// ============================================
// 10. Citation Copy
// ============================================
function copyCitation(button) {
    const codeBlock = button.parentElement.querySelector('code');
    const text = codeBlock.textContent;

    navigator.clipboard.writeText(text).then(() => {
        const originalHTML = button.innerHTML;
        button.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
            Copied!
        `;
        button.style.background = '#16a34a';
        button.style.borderColor = '#16a34a';
        button.style.color = '#fff';

        setTimeout(() => {
            button.innerHTML = originalHTML;
            button.style.background = '';
            button.style.borderColor = '';
            button.style.color = '';
        }, 2000);
    });
}

window.copyCitation = copyCitation;

// ============================================
// 11. Smooth Scroll for Anchor Links
// ============================================
function initSmoothScroll() {
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute('href'));
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });
    });
}

// ============================================
// 12. Fade-in on Scroll
// ============================================
function initFadeIn() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('visible');
                observer.unobserve(entry.target);
            }
        });
    }, { threshold: 0.1, rootMargin: '0px 0px -40px 0px' });

    document.querySelectorAll('.fade-in').forEach(el => {
        observer.observe(el);
    });
}

// ============================================
// 13. Initialize Everything
// ============================================
async function init() {
    // Get DOM references
    scrollSection = document.getElementById('scroll-demo');
    if (!scrollSection) return;

    scrollContainer = scrollSection.querySelector('.scroll-container');
    scrollSticky = scrollSection.querySelector('.scroll-sticky');
    overheadCanvas = document.getElementById('scrollOverheadCanvas');
    overheadCtx = overheadCanvas.getContext('2d');
    overheadCanvas.width = OVERHEAD_W;
    overheadCanvas.height = OVERHEAD_H;
    overheadWrap = document.querySelector('.scroll-overhead-wrap');

    naiveSlots = createSlots('scrollNaiveStrip', TOTAL_SLOTS);
    bppSlots = createSlots('scrollBppStrip', TOTAL_SLOTS);

    naiveContainer = document.getElementById('scrollNaiveContainer');
    bppContainer = document.getElementById('scrollBppContainer');
    frameStripsWrapper = document.getElementById('frameStripsWrapper');
    msg1 = document.getElementById('scrollMsg1');
    msg2 = document.getElementById('scrollMsg2');
    msg3 = document.getElementById('scrollMsg3');
    msg4 = document.getElementById('scrollMsg4');
    bppTitle = document.getElementById('scrollBppTitle');
    scrollSectionHeader = document.getElementById('scrollSectionHeader');
    policyInputHighlight = document.getElementById('policyInputHighlight');
    trajectorySliderContainer = document.getElementById('trajectorySliderContainer');
    trajectorySliderProgress = document.getElementById('trajectorySliderProgress');
    trajectorySliderThumb = document.getElementById('trajectorySliderThumb');
    animationControls = document.getElementById('animationControls');
    playPauseBtn = document.getElementById('playPauseBtn');
    animationSliderTrack = document.getElementById('animationSliderTrack');
    animationSliderProgress = document.getElementById('animationSliderProgress');
    animationSliderThumb = document.getElementById('animationSliderThumb');

    // Load pre-extracted frame images
    await loadFrameImages();

    // Show controls after loading
    if (trajectorySliderContainer) {
        trajectorySliderContainer.classList.add('visible');
    }
    if (animationControls) {
        animationControls.classList.add('visible');
    }

    // Initialize animation controls
    initAnimationControls();

    // Initial render
    updateAnimation(0);

    // Set up auto-play on visibility
    initVisibilityObserver();
}

document.addEventListener('DOMContentLoaded', () => {
    initSmoothScroll();
    initFadeIn();
    initVideoAutoplay();
    init();
});
